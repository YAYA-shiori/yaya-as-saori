「ポストと狛犬」で使ってみたの場合（里々での使用）



さて、このテキストはリアルタイムで、テストをしながら書いています。
ポストと狛犬は、インストールが完了しました。
私は、普段里々を弄っているわけではありませんので、実際のところ、
里々の細かい事情はよくわかっておりません。
というわけで、一緒にテストしてみましょう。
※ポストと狛犬は以下のURLからダウンロードできます。
http://www.geocities.jp/poskoma/


ちなみに、このreadmeの対象者は、ポストと狛犬に最初から入っていた
saoriなら使ったことはあるけれど、自分で、新しいsaoriを追加したことはない。
ぐらいのレベルの人もできるだけわかって頂けるように書いておりますので、
saoriを使いこなしておられる方には、大変まどろっこしい内容かもしれません。
そういった方は、必要個所のみ、読み流す程度で十分でございます。


ちなみに、このreadme.txtで主に解説しているのは、文のビルトイン（システム）関数の実行方法です。
文のビルトイン関数の解説は、
文屋
http://emily.nanika.jp/ayaya/pukiwiki.php?AYA%A5%C9%A5%AD%A5%E5%A5%E1%A5%F3%A5%C8%2FV5%2F%A5%B7%A5%B9%A5%C6%A5%E0%B4%D8%BF%F4#g2041fc9

をご覧ください。
なお、文をSAORIとして使う場合の動作の差異に関して、このファイルの
・留意点　以降に記述がありますので、ご利用の際は、そこだけでもお読みいただきますと、
予想外な動作をしてしまう可能性は若干減るのではないかと思います。




それではテストをはじめましょう。
まず、この配布物と一緒に入っていたファイルのうち
aya5.dll
aya5.txt
ayasaori.aym
builtin.aym
を〜POST_and_KOMAINU\ghost\master\saoriフォルダに入れます
（他のものも入れてしまっても問題は起きませんが）。
どこのフォルダへ置くかに関しては、"satori_conf.txt" にパスが通るように記述して頂ければ、
どこでも結構です。ただテストということで、わかりやすい場所に入れました。
ところで、拡張子のaymというのが、よくわからない拡張子だと思われるでしょうが、
命名としましては、ayaモジュールのつもりです。中身はただのテキストファイルです。
aymは慣習的にそういう名前にしてみただけですので、aya5.txtの方を書き換えて
ファイル名と同じ名前になるようにしていただければ、ayaori.txtでもharunavirus.exe
でも問題ありません。ただしなるべくわかりやすい名前が良いでしょう。


さて、話がそれましたが、まだsaoriフォルダに上記の4ファイルを入れてみただけです。
今度は〜\POST_and_KOMAINU\ghost\masterの
"satori_conf.txt"内、＠SAORIの項目の下の方に、
aya,saori/aya5.dll
と、パスが文のdllと一致するように追記します。
この記述の意味自体がわからない場合は、まず、里々のマニュアル等でご確認ください。
saoriを一度でも使ったことのある方ならなんとなくご理解頂けるでしょう。
念のために書いておきますと、"aya" がエイリアス（文を呼び出す時の名前）で、
"satori/aya5.dll" が "〜\POST_and_KOMAINU\ghost\master" フォルダからの相対パスです。


次は、他の里々のdic〜.txtと同じフォルダに
dic_test.txt
を作成し、

＊1つつかれ
（aya, strlen, てすとてすとてすと）

という2行を追加してみましょう。
strlenというのは、その次の引数（ここでは"てすとてすとてすと")
が何文字かを調べる関数です。"てすとてすとてすと" は数えると9文字ですので、「9」と表示されるはず。
ところで、strlenというのは、AYAのビルトイン（システム）関数です。
ビルトイン関数の詳しい内容は、以下のサイトをご覧ください。

文屋
http://emily.nanika.jp/ayaya/pukiwiki.php?AYA%A5%C9%A5%AD%A5%E5%A5%E1%A5%F3%A5%C8%2FV5%2F%A5%B7%A5%B9%A5%C6%A5%E0%B4%D8%BF%F4#g2041fc9

上のURLではstrlenは大文字でSTRLENですが、このモジュールでは、
大文字でも小文字でも同様に動作いたします。
というのは戻り値を操作しやすいように、内部ではビルトイン関数を直接呼ばないで、
間接的に呼び出す仕組みになっているからです。
builtins.aym がビルトイン関数再定義用のモジュールになっています。
どういう仕組みなのかを考えなくても、まったく差し支えありませんのでご安心ください。




さて、これで文を呼び出す準備は整いました。
さっそくテストをしてみましょう。
ポストと狛犬を起動して、狛犬をダブルクリックしてみます

―ー―ーここでバグを修正すること30分―ー―ー

さて、30分もかかったのは私だけで、みなさんは一瞬で
狛犬のバルーンに「9」と表示されたはずです。

上手くいったので、別の関数を使ってみましょう
先ほどの、
（aya, strlen, てすとてすとてすと）
を
（aya, replace, てすとてすとてすと, てす, とま）
に変えてみてください。
これは "てすとてすとてすと" の "てす" という文字を全て
"とま" という文字に変えてくれます。
どういう表示がされるか予想がつきますでしょうか。

ポストと狛犬をリロードして、狛犬をダブルクリックしてみましょう。
「とまととまととまと」と今回はすっきりと私の期待通りに表示されました。


さて、さらに使う関数を変えてみましょう。
今度はsplitという関数を使ってみます。先ほどの
（aya, strlen, てすとてすとてすと）
という行を
（aya, split, てすとてすとてすと, て）
に変えてみます。
これは "てすとてすとてすと" を "て" という文字で分割するという意味です。
毎度のごとくポスト氏を再起動して、狛犬殿をダブルクリックいたしますと、
狛犬さんのバルーンに「4」と表示されました。
何か、期待を裏切られた感じです。
これは "てすとてすとてすと"の中には "て" が3つあるので、
"て" で分けたら4つの部分に分かれましたという意味の "4" です。
でも、文字を分割したかったのですから、普通はこういう結果が欲しいわけではありませんよね。
私は分かれたそれぞれの部分が欲しいわけです。
それをどうやって表示するかというところですが、
（aya, split, てすとてすとてすと, て）
（Ｓ０）
（Ｓ１）
（Ｓ２）
という風に（Ｓ数字）を書くことで、別れた部分文字列が取れるようです。
試しに（Ｓ０）〜（Ｓ２）をdic_test.txt に書き足して表示させてみましょう。
再び再起動して、ダブルクリックです。
狛犬のバルーンには

4
（Ｓ０）
すと
すと

と表示されました。
どうもバグのような表示ですが、これは一部里々の仕様上の動作だったりします。
（Ｓ０）が（Ｓ０）のままになってしまう原因というのは、
 "てすとてすとてすと" が "て" で4つに分割されたわけですから、
（Ｓ０）は最初の "て" より前、つまり何もない文字（空文字という）なのです。
里々では、空文字ですよ、とsaori側から答えを返しても、空文字は存在しないと認識されてしまうようです。
これは私が思いつく限りではどうしようもないことです。
しかし、まだもう一つ問題が残っています。
（aya, split, てすとてすとてすと, て）
で表示される "4" という数字です。こんなものが表示されていては
あまり芳しくありませんので、どうにかして表示させないようにしないといけないようです。
表示させない方法はどこかのサイトで見たことがある気がしますので探してみましょう。

里々Wiki
http://www.mac.gn.to/satori/index.php?%5B%5BSAORI%B4%D8%CF%A2%5D%5D

で見つけました。nopという、返ってきた値を表示させないようにする里々の標準関数があるようですね。
これを使って
（nop,（aya, split, てすとてすとてすと, て））
（Ｓ０）
（Ｓ１）
（Ｓ２）
と書き換えてもう一度試してみます。

[空行]
（Ｓ０）
すと
すと

頭に空行が入ってしまいましたが、里々の辞書では、何もない行は空行になってしまうので正しい表示ですね。
これは（Ｓ数字）を縦にずらずら並べているからこうなるのであって、横に一行で
（nop,（aya, split, てすとてすとてすと, て））（Ｓ０）（Ｓ１）（Ｓ２）
のように書けば、空行ではなくなるはずです（（Ｓ０）がそのまま表示される問題は解消されていませんが）。
さて、なんとなく使い方はわかっていただけましたでしょうか。

しかし、ここまでテストとして試してきた関数は、よくよく考えてみますと、
ssu.dllでできることばかりです。動作もほとんど一緒ではないでしょうか
（私はssu.dllを使ったことがないのでわかりませんが）。


ここまでの関数を見る限りでは、わざわざ文を使う価値が見出せないことと思いますので、
最後にファイルの読み込みをしてみます。
dic_test.txtを以下のように書き換えてみてください。

＊1つつかれ
（nop,（aya, fopen, aya5.txt, r））
（無限ループ）

＊無限ループ
（aya, fread, aya5.txt）
＞ループ終了	（Ｓ０）＝＝EOF
（無限ループ）

＊ループ終了
（nop,（aya, fclose, aya5.txt））


最後ということで無限ループという鬼の所業を使います。
上記のスクリプトを軽く説明をいたしますと、
ファイルを開く関数がfopen、ファイルから1行ずつ読み込むのがfread、
ファイルを閉じるのがfcloseです。
（fopen, aya5.txt, r） の "r" は読み込み専用で開きますという意味です
（繰り返しますが、文の関数の詳細につきましては文屋をご覧ください）。
そして
＊無限ループ
を使ってfreadを繰り返すことで、ファイルを最後まで読み込むことができるようになっています。
ファイルの最後までくるとfreadを呼んでも、もうそれ以上は何も返ってこなくなり、
代わりに（Ｓ０）がEOFという文字になるので、EOFになったらループを終了するような処理をします。
最後のfcloseはしてもしなくてもポストと狛犬の終了時には文の方で閉じてくれるのでしょうが、
昔ながらのお作法として、使い終わったら閉じるのが基本です。

このサンプルの実行は各自で行ってみてください。
といったところで、だいたいの使い方はご理解いただけましたでしょうか。




・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・留意点
・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・（Ｓ数字）に値が入る関数と入らない関数の見分け方

基本的に、文屋に「汎用配列で返す」と書いてある関数は配列で返す挙動を再現するために
（Ｓ数字）を使っております。まずその辺が目安です（上で使ったfreadは必要上の特殊措置です）。
biltins.aymファイルを覗いて頂けば、該当する関数には、
// Value[0..n]: 分割された文字列
のようにコメントが書いてあるかと思います（Value0 が里々では（Ｓ０）になります）。
といっても、それだけではいささか不親切でありますので、一覧にしてみますと
（Ｓ数字）に値が入る関数は、

any       （（Ｓ０）の内容は選択された引数がn番なら、n - 1）
asearchex （列挙数を返す）
fread     （ファイルを全部読みきったときだけ（Ｓ０）がEOFになる）
getmeminfo
gettime
re_getlen （列挙数を返す）
re_getpos （列挙数を返す）
re_getstr （列挙数を返す）
re_grep   （（Ｓ数字）の内容は、正規表現にマッチした部分文字列）
re_match  （（Ｓ数字）の内容は、正規表現にマッチした部分文字列）
re_replace（（Ｓ数字）の内容は、正規表現にマッチした部分文字列）
re_search （（Ｓ数字）の内容は、正規表現にマッチした部分文字列）
re_split  （分割数を返す）
split     （分割数を返す）
splitpath （分割数を返す）


となります。全て大文字でも同様の動作になります。
これらの関数は、文屋のシステム関数の説明とは返す値が異なっているものもあります。
（getmeminfoとgettimeはそれ自体は何も返ってきません。また、freadはファイルから読み込んだ行を返します）。
これらは、（Ｓ数字）の方を中心に活用することになると思います。



ところで、ビルトイン関数の中にはSAORIとして使った場合意味をなさないものもあります。
例えば toint（"33"（さんさん）のような文字列の数字を整数の33（さんじゅうさん）に変換する）
のような関数は、一度整数に変換しても、栞側に返す時に文字列に戻ってしまいます（プロトコルの制約です）
気づいたものの範囲ですが、そういった関数には、biltins.aym 内で軽く理由付きで
コメントしておきました。

文内部の変数を作ったり弄ったりする
lettoname
erasevar
gettype
savevar
のような関数も使いようによっては使えますが、使いどころは難しいでしょう。


・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・400 Bad Request が返ってきたのですが

一番多い可能性としては、呼び出しの引数が足りない場合です。
詳細は、ayasaori.log を確認してください（それだけではわからない可能性もありますが）。
aya5.txt内の
//log, ayasaori.log
という行の頭の//を消すとayasaori.logというログに記録されます。


・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・サンプル追加モジュール "sample.aym" と "dic_sample.txt" の使用方法について

"dic_sample.txt" は、"sample.aym" モジュールをテストするための里々辞書です。
"dic_sample.txt" は、他の里々辞書と同じフォルダに入れてください。
"sample.aym" の方は、aya5.dll と同じフォルダに入れてください。
"sample.aym" を使用する場合は、 "aya5.txt" の
//dic, sample.aym
という行の頭の // を削って。
dic, sample.aym
となるようにしてください。
同様に、新しいモジュールを追加する場合は、"aya5.txt" に
dic, モジュール名
のように追記していくだけです。


・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・追加モジュールを書ける人向け（主に文ユーザ）

一般的に関数名は、
ModuleName.MethodName
のように書かれるのが良いかと思います。

ModuleName.〜 の同一ModuleName内のいずれかが初めて呼ばれる直前に
ModuleName.Loadという関数が呼ばれますので、必要があればそれを初期化にご活用ください。
また、ModuledName.Unloadという関数が、saoriのアンロード時に呼ばれますので、
ModuleName.Unload関数内で必要な終了処理を行うと良いでしょう。
Loadをファイルの読み込み解析に使用し、Unloadでグローバル変数の削除をする、などが考えられます。
作り方のサンプルは "sample.aym" をご覧ください。
呼び出された関数内で -1 を返すと、400 Bad Request になります。
その他の解説は、"sample.aym" をご覧になれば、おおよそご理解いただけるのではないかと思います。

文5 のマニュアルは下記URL
http://emily.nanika.jp/ayaya/pukiwiki.php?AYA%A5%C9%A5%AD%A5%E5%A5%E1%A5%F3%A5%C8%2FV5%2F%A5%DE%A5%CB%A5%E5%A5%A2%A5%EB




・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・・
・著作権など

アーカイブ内のファイルの改変・再配布は、自由に行ってください。
著作者の明示等は特に必要ありません。

同梱の配布物中の、aya5.dll は、umeici氏が作成されたものです。
aya5及び関連著作物は、以下のサイトから入手できます。
http://umeici.hp.infoseek.co.jp/

The others were writed by 摂理
